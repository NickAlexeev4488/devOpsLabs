# Лабораторная работа №3*

### Требования:
Написать “плохой” Docker Compose файл, в котором есть не менее трех “bad practices” по их написанию.
Написать “хороший” Docker Compose файл, в котором эти плохие практики исправлены.
В Readme описать каждую из плохих практик в плохом файле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат.
После предыдущих пунктов в хорошем файле настроить сервисы так, чтобы контейнеры в рамках этого compose-проекта так же поднимались вместе, но не "видели" друг друга по сети. В отчете описать, как этого добились и кратко объяснить принцип такой изоляции.

## Ход работы

### Установим docker-compose

`sudo apt-get update
sudo apt-get install -y docker.io docker-compose`

### Создадим плохой докер файл

![image](https://github.com/user-attachments/assets/44afacd9-97db-4d9b-a4c8-48c81e3464bd)

### Запустим его

![Screenshot 2024-12-25 010514](https://github.com/user-attachments/assets/e3b65520-3adf-464b-9968-6e0163a950fe)

### Плохие практики и их решения

1. Использование latest для тегов образов
   Проблема: В плохом файле используются latest теги, которые дают последнюю возможную систему, из-за чего могут появиться проблему с несовместимостью.
   Решение: В хорошем файле используется конкреная версия ubuntu.
2. Использование priviliged: true
   Проблема: В плохом файле используются privileged: true, которые дают контейнеру доступ к устройствам хоста и полным правам администратора, что увеличивает риск безопасности.
   Решение: В хорошем файле используются privileged: false.
3. Циклическая зависимость
   Проблема: app1 и app2 пытаются получить доступ друг к другу через curl, создавая циклическую зависимость. Это может привести к проблемам при старте контейнеров, так как каждый контейнер будет ожидать, что другой уже будет готов.
   Решение: В хорошем файле используется подход с явным ожиданием готовности контейнеров, с помощью depends_on.

### Напишем хороший докер файл

![image](https://github.com/user-attachments/assets/8d59d17f-d6f3-40c9-b3b6-e49574e669da)

### Запустим его

![Screenshot 2024-12-25 012127](https://github.com/user-attachments/assets/f5fda0dc-e4f9-4df4-9bb2-668bbf31471a)

### Допишем хороший файл так, чтобы контейнеры друг друга не видели.

![image](https://github.com/user-attachments/assets/2f3d3c3b-1acf-4c03-a5a4-c5e8bb7cf460)

### Запустим его

![Screenshot 2024-12-25 010741](https://github.com/user-attachments/assets/ff6c2497-2abe-4e8d-b65b-5de749c480d0)
![Screenshot 2024-12-25 010802](https://github.com/user-attachments/assets/30da1ad2-244b-4c4e-be89-518a24379153)

В конце вывода видим ошибки Could not resolve host app1 и Could not resolve host app2, это является доказательством того, что контейнеры друг друга не видят, значит все хорошо!

## Вывод

Все файлы написаны, все запускаются, с последним файлом что-то похожее делали на информатике на первом курсе, когда надо было ностроить сеть между 3 машинами и тоже ограничивать им видимость, только тут с контейнерами.




